from collections import deque

# Define the problem formulation
initial_state = (8, 0, 0)
goal_state = (4, 4, 0)

# Function to get the successors of a state
def get_successors(state):
    successors = []
    a, b, c = state
    
    # Pour from A to B
    if a > 0 and b < 5:
        amount_to_pour = min(a, 5 - b)
        new_state = (a - amount_to_pour, b + amount_to_pour, c)
        successors.append(new_state)
    
    # Pour from A to C
    if a > 0 and c < 3:
        amount_to_pour = min(a, 3 - c)
        new_state = (a - amount_to_pour, b, c + amount_to_pour)
        successors.append(new_state)
    
    # Pour from B to A
    if b > 0 and a < 8:
        amount_to_pour = min(b, 8 - a)
        new_state = (a + amount_to_pour, b - amount_to_pour, c)
        successors.append(new_state)
    
    # Pour from B to C
    if b > 0 and c < 3:
        amount_to_pour = min(b, 3 - c)
        new_state = (a, b - amount_to_pour, c + amount_to_pour)
        successors.append(new_state)
    
    # Pour from C to A
    if c > 0 and a < 8:
        amount_to_pour = min(c, 8 - a)
        new_state = (a + amount_to_pour, b, c - amount_to_pour)
        successors.append(new_state)
    
    # Pour from C to B
    if c > 0 and b < 5:
        amount_to_pour = min(c, 5 - b)
        new_state = (a, b + amount_to_pour, c - amount_to_pour)
        successors.append(new_state)
    
    return successors

# Breadth-First Search
def bfs(initial_state, goal_state):
    frontier = deque()
    explored = set()
    frontier.append(initial_state)
    
    while frontier:
        current_state = frontier.popleft()
        explored.add(current_state)
        
        if current_state == goal_state:
            return "Solution found"
        
        for next_state in get_successors(current_state):
            if next_state not in explored and next_state not in frontier:
                frontier.append(next_state)
    
    return "No solution found"

# Solve the problem
result = bfs(initial_state, goal_state)
print(result)
